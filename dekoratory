# %% [markdown]
# # Od zera do Hackera - Dekoratory ğŸ¨

# %% [markdown]
# 
# przygotowaÅ‚a Karolina Stolarczyk

# %%
import time

# %% [markdown]
# Dekoratory sÄ… bardzo przydatnym narzÄ™dziem w Pythonie, bo pozwalajÄ… modyfikowaÄ‡ zachowanie funkcji lub klasy. Dekoratory pozwalajÄ… 'opakowaÄ‡' (wrapp) funkcjÄ™ pierwotnÄ… w innÄ… funkcjÄ™, tym samym nie zmieniajÄ…c trwale funkcji pierwotnej. 

# %% [markdown]
# ## 0. Pewne wÅ‚aÅ›ciwoÅ›ci funkcji: <br>
# 1. moÅ¼na jÄ… zapisaÄ‡ w zmiennej, <br>
# 2. moÅ¼e byÄ‡ parametrem innej funkcji, <br>
# 3. moÅ¼na zwrÃ³ciÄ‡ funkcjÄ™ z funkcji. <br>

# %% [markdown]
# AD 1.

# %%
def upper_text(text):
    return text.upper()

# %%
zmienna = upper_text

# %%
zmienna('od zera do hackera')

# %%
upper_text('od zera do hackera')

# %% [markdown]
# AD 2.

# %%
def exclamation_mark(text):
    return text + ' !'

# %%
def sentence(func): 
    s = func('Pajton nie gryzie') 
    print (s) 

# %%
sentence(exclamation_mark)

# %%
sentence(upper_text)

# %% [markdown]
# AD 3.

# %%
def create_adder(x): 
    def adder(y): 
        return x+y 
    return adder 

# %%
adder_123 = create_adder(123)
# adder_123 ma postaÄ‡:
# def adder(y): 
#     return 123+y 


# %%
adder_123(1)

# %% [markdown]
# ## 1. SkÅ‚adnia dekoratora

# %% [markdown]
# W dekoratorach funkcje sÄ… przyjmowane jako argument innej funkcji, a nastÄ™pnie wywoÅ‚ywane wewnÄ…trz funkcji opakowujÄ…cej.

# %%
# przykÅ‚adowy dekorator
def nasz_decorator(func):

    # nasz_wrapper jest wrapperem NASZEJ FUNKCJI (tej w argumencie) 'func'
    
    # funkcja wewnÄ™trzna ma dostÄ™p do NASZEJ FUNKCJI 'func'
    def nasz_wrapper():
        print("To siÄ™ dzieje przed wywoÅ‚aniem funkcji.")

        # wywoÅ‚anie NASZA FUNKCJA wewnÄ…trz funkcji wrapper.
        func()

        print("To siÄ™ dzieje po wywoÅ‚aniu funkcji.")
        
    return nasz_wrapper

# %%
# funkcja, ktÃ³rÄ… wywoÅ‚amy wewnÄ…trz wrappera
def nasza_funkcja():
    print("Teraz wykonuje siÄ™ NASZA FUNKCJA!")

# %%
# wywoÅ‚anie funkcji z dekoratorem
nasza_funkca_z_dekoratorem = nasz_decorator(nasza_funkcja)
# nasza_funkca_z_dekoratorem = nasza_funkcja

# calling the function
nasza_funkca_z_dekoratorem()

# %% [markdown]
# Praktyczna skÅ‚adnia - przed zdefiniowaniem funkcji dodajemy nazwÄ™ dekoratora z symbolem @ - to daje udekorowanie forever

# %%
@nasz_decorator
def nasza_funkcja2():
    print("Teraz wykonuje siÄ™ NASZA druga FUNKCJA!")

# %%
nasza_funkcja2()

# %% [markdown]
# ## 2. PrzykÅ‚ad - mierzenie czasu wykonywania funkcji

# %%
def measuretime(func):
    def wrapper():
        starttime = time.perf_counter()
        func()
        endtime = time.perf_counter()
        print(f"Czas potrzebny do wykonania funkcji: {endtime - starttime} sekund")
    return wrapper

# %%
@measuretime
def wastetime():
    sum([i**2 for i in range(1000000)])

# %%
wastetime()

# %% [markdown]
# ## 3. PrzykÅ‚ad - testy i debugowanie 

# %%
def debug(func):
    def wrapper():
        print(f"Teraz wykonuje siÄ™ funkcja: {func.__name__}.")
        func()
    return wrapper


# %%
@debug
def more_wastetime():
    sum([i**2 for i in range(5000000)])

# %%
more_wastetime()

# %% [markdown]
# ## 4. Co jeÅ›li funkcje majÄ… argumenty?

# %% [markdown]
# Wtedy musimy we wraperze dodaÄ‡ argumenty w postaci *args, **kwargs.

# %%
def nasz_decorator2(func):
    def wrapper(*args, **kwargs):
        
        print("To siÄ™ dzieje przed wywoÅ‚aniem funkcji.")
        
        # wywoÅ‚anie funkcji z argumentami
        returned_value = func(*args, **kwargs)

        print("To siÄ™ dzieje po wywoÅ‚aniu funkcji.")
        
        # zwrÃ³cenie wywoÅ‚anej funkcji
        return returned_value
        
    return wrapper

# %%
# utworzenie funkcji z dekoratorem
@nasz_decorator2
def sum_two_numbers(a, b):
    return a + b

# %%
a, b = 123, 456
sum_two_numbers(a, b)

# %% [markdown]
# ## 5. PrzykÅ‚ad - mierzenie czasu wywoÅ‚ania funkcji z argumentami

# %%
def measuretime2(func):
    def wrapper(*args, **kwargs):
        starttime = time.perf_counter()
        returned_value = func(*args, **kwargs)
        endtime = time.perf_counter()
        print(f"Czas potrzebny do wykonania funkcji: {endtime - starttime} sekund")
        return returned_value 
    return wrapper

# %%
# utworzenie funkcji z dekoratorem
@measuretime2
def multiply_two_numbers(a, b):
    return a * b

# %%
a, b = 123, 456
multiply_two_numbers(a, b)

# %% [markdown]
# ## 6. PrzykÅ‚ad - testy i debugowanie 

# %%
def debug2(func):
    def wrapper(*args, **kwargs):
        print(f"Teraz wykonuje siÄ™ funkcja: {func.__name__} z args: {args} i kwargs: {kwargs}.")
        returned_value = func(*args, **kwargs)
        print(f"Fuknckja {func.__name__} zostaÅ‚a wykonana z wynikiem: {returned_value}.")
        return returned_value
    return wrapper


# %%
@debug2
def jakas_suma(nbr):
    return sum([i**2 for i in range(nbr)])

# %%
jakas_suma(123456)


